# SPDX-License-Identifier: Apache-2.0
#
# Label-based merge gate (Prow-style, GitHub Actions).
#
# Requirements for auto-merge:
#   1. "lgtm" label     ‚Äî added via /lgtm by a reviewer  listed in OWNERS
#   2. "approve" label   ‚Äî added via /approve by an approver listed in OWNERS
#   3. All required CI status checks must pass
#   4. PR branch must be up-to-date with the base branch (strict mode)
#
# Slash commands (in PR comments):
#   /lgtm            ‚Äî adds lgtm label      (reviewers only)
#   /lgtm cancel     ‚Äî removes lgtm label   (reviewers only)
#   /approve         ‚Äî adds approve label    (approvers only)
#   /approve cancel  ‚Äî removes approve label (approvers only)
#
# Merge pipeline:
#   - When both labels are present the workflow enables auto-merge and
#     updates the PR branch to include the latest base.
#   - If the branch was already current ‚Üí CI passes ‚Üí merged.
#   - If a rebase was needed ‚Üí the workflow performs it automatically.
#     Because the rebase is done by github-actions[bot] (no new code
#     from the contributor), lgtm is preserved.  CI re-runs against
#     the combined code, and if it passes the PR merges.
#
# Stale lgtm removal:
#   - Human pushes or external bot updates (e.g. dependabot rebase)
#     remove "lgtm" and disable auto-merge, requiring re-review.
#   - Only the merge-pipeline rebase (github-actions[bot]) preserves
#     lgtm, because it introduces no new contributor code.
#
# Safety:
#   - Labels added by users NOT in OWNERS are removed automatically.
#   - Slash commands from unauthorized users are ignored with a comment.
#   - OWNERS is always read from the BASE branch, never from the PR.
#   - Uses pull_request_target / issue_comment so the workflow has
#     write access for fork PRs while never executing PR code.

name: Auto Merge

on:
  pull_request_target:
    types: [labeled, synchronize]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write

jobs:
  # ‚îÄ‚îÄ Handle /lgtm and /approve slash commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  slash-command:
    if: >-
      github.event_name == 'issue_comment'
      && github.event.issue.pull_request
      && (
        startsWith(github.event.comment.body, '/lgtm')
        || startsWith(github.event.comment.body, '/approve')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch (OWNERS only)
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            OWNERS
            OWNERS_ALIASES
          sparse-checkout-cone-mode: false

      - name: Process slash command
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT: ${{ github.event.comment.body }}
          SENDER: ${{ github.event.comment.user.login }}
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |
          if [ ! -f OWNERS ]; then
            echo "::error::OWNERS file not found"
            exit 1
          fi

          # Parse the command
          CMD=$(echo "$COMMENT" | head -1 | tr -d '\r')

          case "$CMD" in
            /lgtm)          ACTION="add";    LABEL="lgtm";    SECTION="reviewers"  ;;
            "/lgtm cancel") ACTION="remove"; LABEL="lgtm";    SECTION="reviewers"  ;;
            /approve)          ACTION="add";    LABEL="approve"; SECTION="approvers" ;;
            "/approve cancel") ACTION="remove"; LABEL="approve"; SECTION="approvers" ;;
            *)
              echo "‚ÑπÔ∏è  Unrecognised command: $CMD"
              exit 0
              ;;
          esac

          # Check if sender is in the correct OWNERS section
          IN_SECTION=false
          AUTHORIZED=false
          while IFS= read -r line; do
            if echo "$line" | grep -qE '^[a-z_]+:'; then
              if echo "$line" | grep -qE "^${SECTION}:"; then
                IN_SECTION=true
              else
                IN_SECTION=false
              fi
              continue
            fi
            if [ "$IN_SECTION" = true ]; then
              ENTRY=$(echo "$line" | sed -n 's/^[[:space:]]*-[[:space:]]*//p' | tr -d '[:space:]')
              if [ "$ENTRY" = "$SENDER" ]; then
                AUTHORIZED=true
                break
              fi
            fi
          done < OWNERS

          if [ "$AUTHORIZED" != true ]; then
            echo "‚õî ${SENDER} is not in ${SECTION}"
            gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" \
              --body "‚õî @${SENDER} you are not listed in \`OWNERS\` \`${SECTION}\` ‚Äî \`${CMD}\` ignored."
            exit 0
          fi

          # Apply the label action
          if [ "$ACTION" = "add" ]; then
            gh pr edit "$PR_NUMBER" --add-label "$LABEL" --repo "${{ github.repository }}"
            echo "‚úÖ ${SENDER}: /${LABEL} ‚Üí label added"
          else
            gh pr edit "$PR_NUMBER" --remove-label "$LABEL" --repo "${{ github.repository }}" 2>/dev/null || true
            gh pr merge "$PR_NUMBER" --disable-auto --repo "${{ github.repository }}" 2>/dev/null || true
            echo "‚úÖ ${SENDER}: /${LABEL} cancel ‚Üí label removed"
          fi

  # ‚îÄ‚îÄ Remove stale "lgtm" on external pushes (not our own rebase) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  remove-stale-lgtm:
    if: >-
      github.event.action == 'synchronize'
      && github.event.sender.login != 'github-actions[bot]'
    runs-on: ubuntu-latest
    steps:
      - name: Remove lgtm label and disable auto-merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          gh pr edit "$PR_NUMBER" \
            --remove-label lgtm \
            --repo "${{ github.repository }}" 2>/dev/null || true
          gh pr merge "$PR_NUMBER" --disable-auto \
            --repo "${{ github.repository }}" 2>/dev/null || true
          echo "üîÑ Removed lgtm + disabled auto-merge ‚Äî PR updated by ${{ github.event.sender.login }}"

  # ‚îÄ‚îÄ Validate label & auto-merge when both gates are met ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  handle-label:
    if: >-
      github.event.action == 'labeled'
      && (github.event.label.name == 'lgtm' || github.event.label.name == 'approve')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch (OWNERS only)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          sparse-checkout: |
            OWNERS
            OWNERS_ALIASES
          sparse-checkout-cone-mode: false

      - name: Validate labeler is in OWNERS
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SENDER: ${{ github.event.sender.login }}
          LABEL: ${{ github.event.label.name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          if [ ! -f OWNERS ]; then
            echo "::error::OWNERS file not found on base branch"
            exit 1
          fi

          if [ "$LABEL" = "approve" ]; then
            SECTION="approvers"
          else
            SECTION="reviewers"
          fi

          IN_SECTION=false
          AUTHORIZED=false
          while IFS= read -r line; do
            if echo "$line" | grep -qE '^[a-z_]+:'; then
              if echo "$line" | grep -qE "^${SECTION}:"; then
                IN_SECTION=true
              else
                IN_SECTION=false
              fi
              continue
            fi
            if [ "$IN_SECTION" = true ]; then
              ENTRY=$(echo "$line" | sed -n 's/^[[:space:]]*-[[:space:]]*//p' | tr -d '[:space:]')
              if [ "$ENTRY" = "$SENDER" ]; then
                AUTHORIZED=true
                break
              fi
            fi
          done < OWNERS

          if [ "$AUTHORIZED" = true ]; then
            echo "validated=true" >> "$GITHUB_ENV"
            echo "‚úÖ ${SENDER} is an authorized ${SECTION%s} ‚Äî '${LABEL}' label accepted"
          else
            echo "validated=false" >> "$GITHUB_ENV"
            echo "‚õî ${SENDER} is NOT in ${SECTION} ‚Äî removing '${LABEL}' label"
            gh pr edit "$PR_NUMBER" --remove-label "$LABEL" --repo "${{ github.repository }}"
          fi

      - name: Enable auto-merge and update branch if both labels present
        if: env.validated == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          LABELS=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" \
            --json labels --jq '.labels[].name')

          HAS_LGTM=false
          HAS_APPROVE=false
          echo "$LABELS" | grep -qx "lgtm"    && HAS_LGTM=true
          echo "$LABELS" | grep -qx "approve"  && HAS_APPROVE=true

          echo "lgtm=$HAS_LGTM  approve=$HAS_APPROVE"

          if [ "$HAS_LGTM" = true ] && [ "$HAS_APPROVE" = true ]; then
            echo "üöÄ Both labels present ‚Äî enabling auto-merge (squash)"
            gh pr merge "$PR_NUMBER" --auto --squash --repo "${{ github.repository }}"

            # Update the PR branch so CI runs against latest base.
            # If already up-to-date this is a no-op ‚Üí merge proceeds.
            # If a rebase is needed the synchronize event fires with
            # sender=github-actions[bot] ‚Üí lgtm is preserved ‚Üí CI
            # re-runs ‚Üí auto-merge completes once green.
            echo "üîÑ Updating PR branch to include latest base..."
            gh api -X PUT "repos/${{ github.repository }}/pulls/${PR_NUMBER}/update-branch" \
              2>/dev/null || echo "‚ÑπÔ∏è  Branch already up-to-date"
          else
            echo "‚è≥ Waiting for both lgtm + approve"
          fi
