# SPDX-License-Identifier: Apache-2.0
#
# Label-based merge gate (Prow-style, GitHub Actions).
#
# Requirements for auto-merge:
#   1. "lgtm" label     ‚Äî added by a reviewer  listed in OWNERS
#   2. "approve" label   ‚Äî added by an approver listed in OWNERS
#   3. All required CI status checks must pass
#   4. PR branch must be up-to-date with the base branch (strict mode)
#
# Rebase behaviour (like Prow tide in strict mode):
#   - ANY push to the PR (human, bot, or rebase) removes "lgtm" and
#     disables auto-merge.  The reviewer must re-add "lgtm" after
#     confirming the rebased code is still correct.
#   - When both labels are present the workflow updates the PR branch
#     so CI runs against the latest base + PR code.  If a rebase was
#     needed, lgtm is removed and must be re-applied; if the branch
#     was already current, merge proceeds immediately.
#
# Safety:
#   - Labels added by users NOT in OWNERS are removed automatically.
#   - OWNERS is always read from the BASE branch, never from the PR.
#   - Uses pull_request_target so the workflow has write access for
#     fork PRs while never checking out or executing PR code.

name: Auto Merge

on:
  pull_request_target:
    types: [labeled, synchronize]

permissions:
  contents: write
  pull-requests: write

jobs:
  # ‚îÄ‚îÄ Remove stale "lgtm" on ANY push (human or bot) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  remove-stale-lgtm:
    if: github.event.action == 'synchronize'
    runs-on: ubuntu-latest
    steps:
      - name: Remove lgtm label and disable auto-merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          gh pr edit "$PR_NUMBER" \
            --remove-label lgtm \
            --repo "${{ github.repository }}" 2>/dev/null || true
          gh pr merge "$PR_NUMBER" --disable-auto \
            --repo "${{ github.repository }}" 2>/dev/null || true
          echo "üîÑ Removed lgtm + disabled auto-merge ‚Äî PR updated by ${{ github.event.sender.login }}"

  # ‚îÄ‚îÄ Validate label & auto-merge when both gates are met ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  handle-label:
    if: >-
      github.event.action == 'labeled'
      && (github.event.label.name == 'lgtm' || github.event.label.name == 'approve')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base branch (OWNERS only)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          sparse-checkout: |
            OWNERS
            OWNERS_ALIASES
          sparse-checkout-cone-mode: false

      - name: Validate labeler is in OWNERS
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SENDER: ${{ github.event.sender.login }}
          LABEL: ${{ github.event.label.name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          if [ ! -f OWNERS ]; then
            echo "::error::OWNERS file not found on base branch"
            exit 1
          fi

          # Determine which section to check based on the label
          if [ "$LABEL" = "approve" ]; then
            SECTION="approvers"
          else
            SECTION="reviewers"
          fi

          # Parse the relevant section from OWNERS
          IN_SECTION=false
          AUTHORIZED=false
          while IFS= read -r line; do
            # Detect section headers (e.g. "approvers:" or "reviewers:")
            if echo "$line" | grep -qE '^[a-z_]+:'; then
              if echo "$line" | grep -qE "^${SECTION}:"; then
                IN_SECTION=true
              else
                IN_SECTION=false
              fi
              continue
            fi

            # Check list entries within the target section
            if [ "$IN_SECTION" = true ]; then
              ENTRY=$(echo "$line" | sed -n 's/^[[:space:]]*-[[:space:]]*//p' | tr -d '[:space:]')
              if [ "$ENTRY" = "$SENDER" ]; then
                AUTHORIZED=true
                break
              fi
            fi
          done < OWNERS

          if [ "$AUTHORIZED" = true ]; then
            echo "validated=true" >> "$GITHUB_ENV"
            echo "‚úÖ ${SENDER} is an authorized ${SECTION%s} ‚Äî '${LABEL}' label accepted"
          else
            echo "validated=false" >> "$GITHUB_ENV"
            echo "‚õî ${SENDER} is NOT in ${SECTION} ‚Äî removing '${LABEL}' label"
            gh pr edit "$PR_NUMBER" --remove-label "$LABEL" --repo "${{ github.repository }}"
          fi

      - name: Enable auto-merge and update branch if both labels present
        if: env.validated == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          LABELS=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" \
            --json labels --jq '.labels[].name')

          HAS_LGTM=false
          HAS_APPROVE=false
          echo "$LABELS" | grep -qx "lgtm"    && HAS_LGTM=true
          echo "$LABELS" | grep -qx "approve"  && HAS_APPROVE=true

          echo "lgtm=$HAS_LGTM  approve=$HAS_APPROVE"

          if [ "$HAS_LGTM" = true ] && [ "$HAS_APPROVE" = true ]; then
            echo "üöÄ Both labels present ‚Äî enabling auto-merge (squash)"
            gh pr merge "$PR_NUMBER" --auto --squash --repo "${{ github.repository }}"

            # Update the PR branch so CI runs against latest base.
            # If the branch is already up-to-date this is a no-op and
            # merge proceeds once CI passes.
            # If a rebase IS needed, the synchronize event will fire,
            # lgtm will be removed, and the reviewer must re-add it
            # to confirm the rebased code (Prow strict-tide behaviour).
            echo "üîÑ Updating PR branch to include latest base..."
            gh api -X PUT "repos/${{ github.repository }}/pulls/${PR_NUMBER}/update-branch" \
              2>/dev/null || echo "‚ÑπÔ∏è  Branch already up-to-date"
          else
            echo "‚è≥ Waiting for both lgtm + approve"
          fi
