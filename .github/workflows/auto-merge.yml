# SPDX-License-Identifier: Apache-2.0
#
# Label-based merge gate (Prow-style, GitHub Actions).
#
# Requirements for auto-merge:
#   1. "lgtm" label     ‚Äî added via /lgtm by a reviewer  listed in OWNERS
#   2. "approve" label   ‚Äî added via /approve by an approver listed in OWNERS
#   3. All required CI status checks must pass
#
# Slash commands (in PR comments, one per line, can combine in one comment):
#   /lgtm            ‚Äî adds lgtm label      (reviewers only)
#   /lgtm cancel     ‚Äî removes lgtm label   (reviewers only)
#   /approve         ‚Äî adds approve label    (approvers only)
#   /approve cancel  ‚Äî removes approve label (approvers only)
#
# Safety:
#   - Any push to a PR removes "lgtm" and disables auto-merge.
#   - Labels added by users NOT in OWNERS are removed automatically.
#   - Slash commands from unauthorized users are ignored with a comment.
#   - OWNERS is always read from the BASE branch, never from the PR.
#   - PRs that modify .github/workflows/, OWNERS, or OWNERS_ALIASES
#     are never auto-merged ‚Äî a maintainer must merge manually.
#   - Uses pull_request_target / issue_comment so the workflow has
#     write access for fork PRs while never executing PR code.

name: Auto Merge

on:
  pull_request_target:
    types: [labeled, synchronize]
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: auto-merge-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: false

jobs:
  # ‚îÄ‚îÄ Handle /lgtm and /approve slash commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  slash-command:
    if: >-
      github.event_name == 'issue_comment'
      && github.event.issue.pull_request
      && (
        startsWith(github.event.comment.body, '/lgtm')
        || startsWith(github.event.comment.body, '/approve')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout base branch (OWNERS only)
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            OWNERS
            OWNERS_ALIASES
          sparse-checkout-cone-mode: false

      - name: Process slash command
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT: ${{ github.event.comment.body }}
          SENDER: ${{ github.event.comment.user.login }}
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO: ${{ github.repository }}
        run: |
          if [ ! -f OWNERS ]; then
            echo "::error::OWNERS file not found"
            exit 1
          fi

          # Helper: check if user is in an OWNERS section
          check_owners() {
            local section="$1"
            local IN_SECTION=false
            while IFS= read -r line; do
              if echo "$line" | grep -qE '^[a-z_]+:'; then
                if echo "$line" | grep -qE "^${section}:"; then
                  IN_SECTION=true
                else
                  IN_SECTION=false
                fi
                continue
              fi
              if [ "$IN_SECTION" = true ]; then
                local ENTRY
                ENTRY=$(echo "$line" | sed -n 's/^[[:space:]]*-[[:space:]]*//p' | tr -d '[:space:]')
                if [ "$ENTRY" = "$SENDER" ]; then
                  return 0
                fi
              fi
            done < OWNERS
            return 1
          }

          # Extract all slash commands (one per line, must start at ^)
          CMDS=$(echo "$COMMENT" | tr -d '\r' | grep -E '^/(lgtm|approve)( cancel)?$' || true)

          if [ -z "$CMDS" ]; then
            echo "‚ÑπÔ∏è  No recognised slash commands found"
            exit 0
          fi

          CANCELLED=false

          while IFS= read -r CMD; do
            case "$CMD" in
              /lgtm)             ACTION="add";    LABEL="lgtm";    SECTION="reviewers"  ;;
              "/lgtm cancel")    ACTION="remove"; LABEL="lgtm";    SECTION="reviewers"  ;;
              /approve)          ACTION="add";    LABEL="approve"; SECTION="approvers" ;;
              "/approve cancel") ACTION="remove"; LABEL="approve"; SECTION="approvers" ;;
              *) continue ;;
            esac

            if ! check_owners "$SECTION"; then
              echo "‚õî ${SENDER} is not in ${SECTION}"
              gh pr comment "$PR_NUMBER" --repo "$REPO" \
                --body "‚õî @${SENDER} you are not listed in \`OWNERS\` \`${SECTION}\` ‚Äî \`${CMD}\` ignored."
              continue
            fi

            if [ "$ACTION" = "add" ]; then
              gh pr edit "$PR_NUMBER" --add-label "$LABEL" --repo "$REPO"
              echo "‚úÖ ${SENDER}: ${CMD} ‚Üí label added"
            else
              gh pr edit "$PR_NUMBER" --remove-label "$LABEL" --repo "$REPO" 2>/dev/null || true
              gh pr merge "$PR_NUMBER" --disable-auto --repo "$REPO" 2>/dev/null || true
              echo "‚úÖ ${SENDER}: ${CMD} ‚Üí label removed + auto-merge disabled"
              CANCELLED=true
            fi
          done <<< "$CMDS"

          # If any cancel was processed, skip auto-merge check
          if [ "$CANCELLED" = true ]; then
            exit 0
          fi

          # Check if both labels are present and enable auto-merge
          LABELS=$(gh pr view "$PR_NUMBER" --repo "$REPO" \
            --json labels --jq '.labels[].name')

          HAS_LGTM=false
          HAS_APPROVE=false
          echo "$LABELS" | grep -qx "lgtm"    && HAS_LGTM=true
          echo "$LABELS" | grep -qx "approve"  && HAS_APPROVE=true

          echo "lgtm=$HAS_LGTM  approve=$HAS_APPROVE"

          if [ "$HAS_LGTM" = true ] && [ "$HAS_APPROVE" = true ]; then
            # Block auto-merge for PRs that touch sensitive files
            SENSITIVE=$(gh pr view "$PR_NUMBER" --repo "$REPO" \
              --json files --jq '[.files[].path | select(
                startswith(".github/workflows/") or
                . == "OWNERS" or
                . == "OWNERS_ALIASES"
              )] | join(", ")')

            if [ -n "$SENSITIVE" ]; then
              echo "üõë PR modifies sensitive files: $SENSITIVE ‚Äî auto-merge blocked"
              gh pr comment "$PR_NUMBER" --repo "$REPO" \
                --body "üõë This PR modifies sensitive files (\`$SENSITIVE\`). Auto-merge is **blocked** for safety. A maintainer must merge manually after review."
              exit 0
            fi

            echo "üöÄ Both labels present ‚Äî submitting review + enabling auto-merge"
            if ! REVIEW_ERR=$(gh pr review "$PR_NUMBER" --approve --repo "$REPO" \
              --body "Auto-approved: lgtm + approve verified in OWNERS." 2>&1); then
              echo "‚ö†Ô∏è  Review submission failed: $REVIEW_ERR"
            fi
            if ! MERGE_ERR=$(gh pr merge "$PR_NUMBER" --auto --merge --repo "$REPO" 2>&1); then
              echo "‚ö†Ô∏è  Auto-merge could not be enabled: $MERGE_ERR"
            fi
          else
            echo "‚è≥ Waiting for both lgtm + approve"
          fi

  # ‚îÄ‚îÄ Remove stale "lgtm" on any push ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  remove-stale-lgtm:
    if: github.event.action == 'synchronize'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Remove lgtm label and disable auto-merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
          SENDER: ${{ github.event.sender.login }}
        run: |
          gh pr edit "$PR_NUMBER" \
            --remove-label lgtm \
            --repo "$REPO" 2>/dev/null || true
          gh pr merge "$PR_NUMBER" --disable-auto \
            --repo "$REPO" 2>/dev/null || true
          echo "üîÑ Removed lgtm + disabled auto-merge ‚Äî PR updated by ${SENDER}"

  # ‚îÄ‚îÄ Guard labels added via GitHub UI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  handle-label:
    if: >-
      github.event.action == 'labeled'
      && (github.event.label.name == 'lgtm' || github.event.label.name == 'approve')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout base branch (OWNERS only)
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          sparse-checkout: |
            OWNERS
            OWNERS_ALIASES
          sparse-checkout-cone-mode: false

      - name: Validate labeler is in OWNERS
        id: validate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SENDER: ${{ github.event.sender.login }}
          LABEL: ${{ github.event.label.name }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          if [ ! -f OWNERS ]; then
            echo "::error::OWNERS file not found on base branch"
            exit 1
          fi

          if [ "$LABEL" = "approve" ]; then
            SECTION="approvers"
          else
            SECTION="reviewers"
          fi

          IN_SECTION=false
          AUTHORIZED=false
          while IFS= read -r line; do
            if echo "$line" | grep -qE '^[a-z_]+:'; then
              if echo "$line" | grep -qE "^${SECTION}:"; then
                IN_SECTION=true
              else
                IN_SECTION=false
              fi
              continue
            fi
            if [ "$IN_SECTION" = true ]; then
              ENTRY=$(echo "$line" | sed -n 's/^[[:space:]]*-[[:space:]]*//p' | tr -d '[:space:]')
              if [ "$ENTRY" = "$SENDER" ]; then
                AUTHORIZED=true
                break
              fi
            fi
          done < OWNERS

          if [ "$AUTHORIZED" = true ]; then
            echo "result=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ ${SENDER} is an authorized ${SECTION%s} ‚Äî '${LABEL}' label accepted"
          else
            echo "result=false" >> "$GITHUB_OUTPUT"
            echo "‚õî ${SENDER} is NOT in ${SECTION} ‚Äî removing '${LABEL}' label"
            gh pr edit "$PR_NUMBER" --remove-label "$LABEL" --repo "$REPO"
          fi

      - name: Enable auto-merge if both labels present
        if: steps.validate.outputs.result == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          LABELS=$(gh pr view "$PR_NUMBER" --repo "$REPO" \
            --json labels --jq '.labels[].name')

          HAS_LGTM=false
          HAS_APPROVE=false
          echo "$LABELS" | grep -qx "lgtm"    && HAS_LGTM=true
          echo "$LABELS" | grep -qx "approve"  && HAS_APPROVE=true

          echo "lgtm=$HAS_LGTM  approve=$HAS_APPROVE"

          if [ "$HAS_LGTM" = true ] && [ "$HAS_APPROVE" = true ]; then
            # Block auto-merge for PRs that touch sensitive files
            SENSITIVE=$(gh pr view "$PR_NUMBER" --repo "$REPO" \
              --json files --jq '[.files[].path | select(
                startswith(".github/workflows/") or
                . == "OWNERS" or
                . == "OWNERS_ALIASES"
              )] | join(", ")')

            if [ -n "$SENSITIVE" ]; then
              echo "üõë PR modifies sensitive files: $SENSITIVE ‚Äî auto-merge blocked"
              gh pr comment "$PR_NUMBER" --repo "$REPO" \
                --body "üõë This PR modifies sensitive files (\`$SENSITIVE\`). Auto-merge is **blocked** for safety. A maintainer must merge manually after review."
              exit 0
            fi

            echo "üöÄ Both labels present ‚Äî submitting review + enabling auto-merge"
            if ! REVIEW_ERR=$(gh pr review "$PR_NUMBER" --approve --repo "$REPO" \
              --body "Auto-approved: lgtm + approve verified in OWNERS." 2>&1); then
              echo "‚ö†Ô∏è  Review submission failed: $REVIEW_ERR"
            fi
            if ! MERGE_ERR=$(gh pr merge "$PR_NUMBER" --auto --merge --repo "$REPO" 2>&1); then
              echo "‚ö†Ô∏è  Auto-merge could not be enabled: $MERGE_ERR"
            fi
          else
            echo "‚è≥ Waiting for both lgtm + approve"
          fi
